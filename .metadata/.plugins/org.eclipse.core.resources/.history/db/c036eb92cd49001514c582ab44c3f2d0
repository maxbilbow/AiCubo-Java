package click.rmx.engine.physics;

import click.rmx.engine.Node;
import click.rmx.engine.math.Vector3;

public class BoundingBox extends CollisonBounds {
	

	static final int MIN = 0, MAX = 1;
	static final int FRONT = 0, BACK = 1, LEFT = 2 , RIGHT = 3, TOP = 4, BOTTOM = 5;
	
	public BoundingBox(Node node) {
		super(node);
		// TODO Auto-generated constructor stub
	}
public float xMin() {
    	return - this.transform.getWidth() / 2;
    }
    public float yMin() {
    	return - this.transform.getHeight() / 2;
    }
    public float zMin() {
    	return - this.transform.getLength() / 2;
    }
    public float xMax() {
    	return - this.transform.getWidth() / 2;
    }
    public float yMax() {
    	return - this.transform.getHeight() / 2;
    }
    public float zMax() {
    	return - this.transform.getWidth() / 2;
    }
    
    public boolean intersects(BoundingBox other) {
    	Vector3 a = this.transform.position();
    	Vector3 b = other.transform.position();
    	
    	if (this.xMin() + a.x > other.xMax() + b.x)
    		return false;
    	if (this.yMin() + a.y > other.yMax() + b.y)
    		return false;
    	if (this.zMin() + a.z > other.zMax() + b.z)
    		return false;
    	if (this.xMax() + a.x < other.xMin() + b.x)
    		return false;
    	if (this.yMax() + a.y < other.xMin() + b.y)
    		return false;
    	if (this.zMax() + a.z < other.xMin() + b.z)
    		return false;
//    	for (int i=0; i<faces.length;) {
//    		if (this.didIntersect(thisPos, otherPos, this.faces[i][MAX], other.faces[i][MIN]))
//    				return false;
//    		if (this.didIntersect(otherPos, thisPos, other.faces[i][MAX], this.faces[i][MIN]))
//    				return false;
//    	}

        // All tests failed, we have a intersection
        return true;
    }
    
//    boolean didIntersect(Vector3 maxPos, Vector3 minPos, Vector3 max, Vector3 min) {
//    	return (
//    		maxPos.x + max.x < minPos.x + min.x ||
//    		maxPos.y + max.y < minPos.y + min.y ||
//    		maxPos.z + max.z < minPos.z + min.z
//    		);
//    }
    
    
   
}
