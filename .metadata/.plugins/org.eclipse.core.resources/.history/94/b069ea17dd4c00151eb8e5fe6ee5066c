package click.rmx.engine.behaviours;

import click.rmx.engine.Node;
import click.rmx.engine.NodeComponent;
import click.rmx.engine.Transform;
import click.rmx.engine.math.Vector3;

public abstract class Behaviour extends NodeComponent implements IBehaviour {
	public static final String 
	AI_STATE_NULL = "AI_STATE_NULL",
	AI_STATE_POSSESSED = "AI_STATE_POSSESSED";
//	void setNode(Node node);
	
//	public Node getNode();
	
	
	protected long interval() {
		return 800;
	}
	
	public void setNotStuck() {
		this.setStuck(STUCK_FALSE);
	}
	
	public boolean isStuck(long tick) {
		int state = stuckState();
		if (state == STUCK_MAYBE && tick - stuckTime > interval() ) {
			Transform root = this.transform().rootTransform();
			Vector3 diff = root.position().getVectorTo(stuckPosition);
				state = diff.x < root.getWidth() &&
						diff.y < root.getHeight() &&
						diff.z < root.getLength() ? STUCK_TRUE : STUCK_FALSE;
				this.setValue(KEY_IS_STUCK, state);
				
		} 
		
		return state == STUCK_TRUE ? true : false;
	}
	
	/**
	 * Overriden so that multiple behaviours can share the same variables
	 */
	public Object getValue(String forKey) {
		return this.getNode().getValue(forKey);
	}
	
	/**
	 * Overriden so that multiple behaviours can share the same variables
	 */
	public Object setValue(String forKey, Object value) {
		return this.getNode().setValue(forKey, value);
	}
	
//	public abstract void update(long tick);
	
	public void lateUpdate() {
		
	};
	
	public void setNode(Node node) {
		super.setNode(node);
		this.onAwake();
	}

	public void turnToFace(Vector3 position) {
		// TODO Auto-generated method stub
	}
//	public boolean isEnabled();
}

