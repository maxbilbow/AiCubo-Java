package click.rmx.engine;

import static org.lwjgl.opengl.GL11.*;


import java.nio.ByteBuffer;
import org.lwjgl.BufferUtils;
import org.lwjgl.opengl.GL11;

import click.rmx.RMXObject;
import click.rmx.engine.ANodeComponent;
import click.rmx.engine.Geometry;
import click.rmx.engine.Node;
import click.rmx.engine.gl.Mesh;
import click.rmx.engine.math.Matrix4;
import click.rmx.engine.math.Vector3;
import click.rmx.engine.math.Vector4;


public abstract class GeometryImpl extends ANodeComponent implements Geometry {

	private Shape shape;
	private boolean visible = true;
		
	public GeometryImpl(Shape shape) {
		this.shape = shape;
	}
	
	public GeometryImpl() {
		this.shape = Shapes.Cube;
	}

	public boolean isVisible() {
		return this.visible;
	}
	private Matrix4 _modelView = new Matrix4();
	private Vector4 color;


	
	public void render(Node node) {//, Object modelMatrix) {

	
		_modelView.set(node.transform().worldMatrix());

		Vector3 modelA = node.transform().eulerAngles();
		//		EulerAngles modelB = base.eulerAngles();
		modelA.scale(1 / click.rmx.RMX.PI_OVER_180);

		glPushMatrix();

		glTranslatef(
				_modelView.m30,// + m.m30, 
				_modelView.m31,// + m.m31,
				_modelView.m32 // + m.m32
				);

		glRotatef(modelA.x, 1,0,0);
		glRotatef(modelA.y, 0,1,0);
		glRotatef(modelA.z, 0,0,1);

		float 
		X = node.transform().scale().x,
		Y = node.transform().scale().y,
		Z = node.transform().scale().z;
		drawWithScale(X, Y, Z);

		GL11.glPopMatrix();

	}
	
	protected abstract void drawWithScale(float x, float y, float z);


	public static GeometryImpl cube() {
		return new GeometryImpl() {//Mesh.vertices1, Mesh.normals1, Mesh.colors1) {
				@Override
				protected void drawWithScale(float X, float Y, float Z) {
					GL11.glBegin(GL11.GL_QUADS);    
					GL11.glColor3f(1.0f,1.0f,0.0f);   
					glNormal3f(0,1,0);
					GL11.glVertex3f( X, Y,-Z);        
					GL11.glVertex3f(-X, Y,-Z);        
					GL11.glVertex3f(-X, Y, Z);
					GL11.glVertex3f( X, Y, Z);  
					GL11.glColor3f(1.0f,0.5f,0.0f);  
					glNormal3f(0,-1,0);
					GL11.glVertex3f( X,-Y, Z);
					GL11.glVertex3f(-X,-Y, Z);
					GL11.glVertex3f(-X,-Y,-Z);
					GL11.glVertex3f( X,-Y,-Z);
					GL11.glColor3f(1.0f,0.0f,0.0f);
					glNormal3f(0,0,1);
					GL11.glVertex3f( X, Y, Z);
					GL11.glVertex3f(-X, Y, Z);
					GL11.glVertex3f(-X,-Y, Z);
					GL11.glVertex3f( X,-Y, Z);
					GL11.glColor3f(1.0f,1.0f,0.0f);
					glNormal3f(0,0,-1);
					GL11.glVertex3f( X,-Y,-Z);
					GL11.glVertex3f(-X,-Y,-Z);
					GL11.glVertex3f(-X, Y,-Z);
					GL11.glVertex3f( X, Y,-Z);
					GL11.glColor3f(0.0f,0.0f,1.0f);
					glNormal3f(-1,0,0);
					GL11.glVertex3f(-X, Y, Z);
					GL11.glVertex3f(-X, Y,-Z);
					GL11.glVertex3f(-X,-Y,-Z);
					GL11.glVertex3f(-X,-Y, Z);
					GL11.glColor3f(1.0f,0.0f,1.0f);
					glNormal3f(1,0,0);
					GL11.glVertex3f( X, Y,-Z);
					GL11.glVertex3f( X, Y, Z);
					GL11.glVertex3f( X,-Y, Z);
					GL11.glVertex3f( X,-Y,-Z);
					GL11.glEnd();    
				}

				

			};
	}

	
	public Shape getShape() {
		return this.shape;
	}

	public void setShape(Shape shape) {	
		this.shape = shape;
	}
	
	
	public Vector4 getColor() {
		return this.color;
	}
	
	
	public void setColor(Vector4 color) {
		this.color = color;
	}
	
	@Override
	public void setVisible(boolean visible) {
		this.visible = visible;
	}
}
