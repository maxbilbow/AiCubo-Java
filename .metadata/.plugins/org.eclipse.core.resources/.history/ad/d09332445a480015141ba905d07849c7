package click.rmx.engine;

import static click.rmx.RMX.getCurrentFramerate;

import click.rmx.engine.math.Matrix4;
import click.rmx.engine.math.Vector3;

public class PhysicsBody extends NodeComponent {

	float mass = 0;
	private Vector3 lastPosition, forces, torque, velocity;
	
	public PhysicsBody() {
		this.lastPosition = new Vector3();
		this.forces = new Vector3();
		this.torque = new Vector3();
		this.velocity = new Vector3();
	}
	public float getMass() {
		return mass;
	}
	
	public float TotalMass() {
		return this.getNode().transform.mass();
	}
	
	
	
	public void setMass(float mass) {
		this.mass = mass;
	}

	public void applyForce(float force, Vector3 direction, Vector3 atPoint) {
		this.forces.x += direction.x * force;
		this.forces.y += direction.y * force;
		this.forces.z += direction.z * force;
	}

	public void updatePhysics(PhysicsWorld physics){
		Node node = this.getNode();
		this.applyGravity(physics.getGravity());
		lastPosition.set(node.transform.position());
		
		node.transform.translate(forces);
		this.forces.scale(1 - physics.getFriction());
		this.updateVelocity();
		
	}
	
	private void updateVelocity() {
		this.velocity.x = this.transform().position().x - this.lastPosition.x;
		this.velocity.y = this.transform().position().x - this.lastPosition.y;
		this.velocity.z = this.transform().position().x - this.lastPosition.z;
	}
	
	public static final String
	ApplyForce = "ApplyForce";

	private void applyGravity(Vector3 g) {
		float ground = 0;
		float mass = getNode().transform.mass();
		float framerate = getCurrentFramerate();
		float height = this.getNode().transform.worldMatrix().m31;
		if (height > ground) {
			//			System.out.println(node.getName() + " >> BEFORE: " + m.position());
			this.forces.x += g.x * framerate * mass;
			this.forces.y += g.y * framerate * mass;
			this.forces.z += g.z * framerate * mass;
		} else if (this.getNode().getParent().getParent() == null)
		
		}

	}
}
