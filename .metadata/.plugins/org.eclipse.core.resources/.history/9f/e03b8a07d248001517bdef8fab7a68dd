package click.rmx.engine;




import static org.lwjgl.glfw.GLFW.GLFW_KEY_W;
import static org.lwjgl.glfw.GLFW.GLFW_KEY_S;
import static org.lwjgl.glfw.GLFW.GLFW_KEY_A;
import static org.lwjgl.glfw.GLFW.GLFW_KEY_D;
import static org.lwjgl.glfw.GLFW.GLFW_KEY_Q;
import static org.lwjgl.glfw.GLFW.GLFW_KEY_E;
import static org.lwjgl.glfw.GLFW.GLFW_KEY_X;
import static org.lwjgl.glfw.GLFW.GLFW_KEY_Z;
import static org.lwjgl.glfw.GLFW.glfwDestroyWindow;
import static org.lwjgl.glfw.GLFW.glfwTerminate;

import org.lwjgl.glfw.GLFW;
import org.lwjgl.opengl.GL11;

import com.maxbilbow.aicubo.AxisGenerator;
import com.maxbilbow.aicubo.EntityGenerator;

import click.rmx.Bugger;
import click.rmx.RMXObject;
import click.rmx.engine.behaviours.SpriteBehaviour;
import click.rmx.engine.gl.GLView;

import click.rmx.engine.gl.KeyStates;
import click.rmx.engine.gl.SharedLibraryLoader;
import click.rmx.engine.math.Tools;
import click.rmx.engine.math.Vector3;

import static org.lwjgl.glfw.GLFW.GLFW_KEY_SPACE;
import static org.lwjgl.glfw.GLFW.GLFW_KEY_RIGHT;
import static org.lwjgl.glfw.GLFW.GLFW_KEY_LEFT;
import static org.lwjgl.glfw.GLFW.GLFW_KEY_UP;
import static org.lwjgl.glfw.GLFW.GLFW_KEY_DOWN;



public class GameController extends RMXObject implements RenderDelegate, Runnable  {
	private GLView view;

	protected GameController() {	
		this.setView(new GameView());
		
	}
	
	public GLView getView() {
		return this.view;
	}
	
	public static GameController getInstance() {
		if(singleton == null) {
			  synchronized(GameController.class) {
		    	 if(singleton == null) {
		    	   singleton = new GameController();
		    	   singleton.setView(new GameView());
		       }
		     }
		  }
		  return singleton;
	}
	
	private static GameController singleton = new GameController();
	
	private void initpov() {
		Node body = Node.getCurrent();
		body.setPhysicsBody(new PhysicsBody());
		body.physicsBody().setMass(5.0f);
		body.addBehaviour(new SpriteBehaviour());
		body.transform.setScale(2f, 10.0f, 2f);	
		Scene.getCurrent().rootNode.addChild(body);
		Node head = new Node();
		head.setCamera(new Camera());
		body.addBehaviour(new Behaviour(){

			public void lookUp(String speed) {
				
			}
			
			public void broadcastMessage(String message, Object args) {
				if (message == "lookUp") {
					float delta = Float.parseFloat(args);
					this.getNode().transform.rotate("pitch", delta);
				}
			}
			@Override
			public void update() {
				// TODO Auto-generated method stub
				
			}
			
		});
	}
	public void setup() {	
		Bugger.log("Setting up scene...");
		Scene scene = Scene.getCurrent();
		Bugger.log("SUCCESS");
		scene.setRenderDelegate(this);
		Bugger.log("Setting up actors...");
		initpov();		
		Bugger.log("POV success");
		Bugger.log("Initializing entity generator");
		EntityGenerator eg = new EntityGenerator() {

			@Override
			public Node makeEntity() {
				float speed = (float) (Tools.rBounds(1, 50) / 100);
				float rotation = (float) (Tools.rBounds(1, (int)speed * 100) / 100);
				Node body = Node.makeCube(0.3f, true, new Behaviour() {
					@Override
					public void update() {
						this.getNode().broadcastMessage("applyForce","forward:"+speed);
//						this.getNode().transform.move("forward:0.5");
						this.getNode().physicsBody().applyTorque(rotation, Vector3.Y, Vector3.Zero);
					}
					
				});
				body.addBehaviour(new SpriteBehaviour());
				body.physicsBody().setMass(1.0f);
				Node head = Node.makeCube(0.1f, false, new Behaviour() {
					@Override
					public void update() {
						this.getNode().transform.move("yaw:0.1");
						this.getNode().transform.move("pitch:0.1");
						this.getNode().transform.move("roll:0.1");
					}
				});
				
				body.addChild(head);
				head.transform.setPosition(0, //put head where a head should be
						body.transform.scale().y + head.transform.scale().y,
						body.transform.scale().z + head.transform.scale().z);
				return body;
			}
			
		};
		Bugger.log("Entity generator initialized");
		eg.yMin = eg.yMax = 0;
		eg.xMax = eg.xMax = eg.zMin = eg.zMax = 0;
		
		Bugger.log("Generating...");
		eg.makeShapesAndAddToScene(scene, 100);
		Bugger.log("Success. Creating floor");
		Node floor = new Node();
		floor.transform.setPosition(0,0,0);
		scene.rootNode.addChild(floor);
		float inf = 99999;//Float.POSITIVE_INFINITY;
		floor.setGeometry(new Geometry(4*3){

			@Override
			protected void drawWithScale(float x, float y, float z) {
				
				GL11.glBegin(GL11.GL_POLYGON);    
	            GL11.glColor3f(0.8f,0.8f,0.8f);           
	            GL11.glVertex3f( inf, -y,-inf);        
	            GL11.glVertex3f(-inf, -y,-inf);        
	            GL11.glVertex3f(-inf, -y, inf);
	            GL11.glVertex3f( inf, -y, inf);  	
	            GL11.glEnd(); 
			}
			
		});
		
		AxisGenerator ag = new AxisGenerator(inf);
		ag.makeShapesAndAddToScene(scene, 1);
		Bugger.log("Actors set up successfully...");
	}

        @Override
	public void run() {
//        
       System.out.println("Hello LWJGL " + GLFW.glfwGetVersionString() + "!");
       Bugger.log("Setup GameController");
       this.setup();
        try {
        	
            Bugger.log("Load Shared Libraries");
            SharedLibraryLoader.load();
            
            Bugger.log("Init GL");
            this.view.initGL();
            
            Bugger.log("Enter Gameloop");
            this.view.enterGameLoop();
 
            // Release window and window callbacks
            glfwDestroyWindow(view.window());
            view.keyCallback().release();
        } catch (Exception e){
        	e.printStackTrace();
        } finally {
            // Terminate GLFW and release the GLFWerrorfun
            glfwTerminate();
            view.errorCallback().release();
        }
    }

	@Override
	public void updateBeforeSceneLogic(Object... args) {
		this.repeatedKeys();	
	}

	@Override
	public void updateBeforeSceneRender(Object... args) {
		
	}
	
	public final KeyStates keys = new KeyStates();
	
	private void repeatedKeys() {
		Node player = Node.getCurrent();
	
		if (this.keys.getOrDefault(GLFW_KEY_W, false)) {
			player.broadcastMessage("applyForce","forward:-1");
		}
		
		if (this.keys.getOrDefault(GLFW_KEY_S, false)) {
			player.broadcastMessage("applyForce","forward:1");
		}
		
		if (this.keys.getOrDefault(GLFW_KEY_A, false)) {
			player.broadcastMessage("applyForce","left:-1");
		}
		
		if (this.keys.getOrDefault(GLFW_KEY_D, false)) {
			player.broadcastMessage("applyForce","left:1");
		}
		
		if (this.keys.getOrDefault(GLFW_KEY_Q, false)) {
			player.broadcastMessage("applyForce","up:-1");
		}
		
		if (this.keys.getOrDefault(GLFW_KEY_E, false)) {
			player.broadcastMessage("applyForce","up:1");
		}
		
		
		if (this.keys.getOrDefault(GLFW_KEY_RIGHT, false)) {
			player.broadcastMessage("applyTorque","yaw:0.5");
		}
		
		if (this.keys.getOrDefault(GLFW_KEY_LEFT, false)) {
			player.broadcastMessage("applyTorque","yaw:-0.5");
		}
		
		if (this.keys.getOrDefault(GLFW_KEY_UP, false)) {
			player.broadcastMessage("applyTorque","pitch:-0.5");
		}
		
		if (this.keys.getOrDefault(GLFW_KEY_DOWN, false)) {
			player.broadcastMessage("applyTorque","pitch:0.5");
		}
		
		if (this.keys.getOrDefault(GLFW_KEY_X, false)) {
			player.broadcastMessage("applyTorque","roll:0.2");
		}
		
		if (this.keys.getOrDefault(GLFW_KEY_Z, false)) {
			player.broadcastMessage("applyTorque","roll:-0.2");
		}
	}
	
	
	public void setView(GLView view) {
		this.view = view;
		this.view.setDelegate(this);
	}
//	private Thread thread;
	public void Start() {
//			thread = new Thread(this,"Game");
//			thread.start();
			this.run();
	}
	

}

