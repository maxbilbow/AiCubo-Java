package com.maxbilbow.aicubo.ants;

import com.maxbilbow.aicubo.AiCubo;
import com.maxbilbow.aicubo.ai.Strategy.AiMethod;
import com.maxbilbow.aicubo.ai.Strategy.State;
import com.maxbilbow.aicubo.ai.Strategy;
import com.maxbilbow.aicubo.ai.StrategyEngine;
import com.maxbilbow.aicubo.ai.StrategyEngine.IMethods;

import static org.lwjgl.glfw.GLFW.*;

import java.util.HashMap;
import java.util.LinkedList;

import click.rmx.RMX;
import click.rmx.engine.Node;
import click.rmx.engine.behaviours.Behaviour;
import click.rmx.engine.behaviours.ICollisionHandler;
import click.rmx.engine.behaviours.SpriteBehaviour;
import click.rmx.engine.gl.IKeyCallback;
import click.rmx.engine.math.Matrix4;
import click.rmx.engine.math.Tools;
import click.rmx.engine.math.Vector3;
import click.rmx.engine.physics.CollisionEvent;

public class AntBehaviour extends SpriteBehaviour implements ICollisionHandler, IKeyCallback {
	public static final String
	Possessed = Behaviour.AI_STATE_POSSESSED, //0
	Amble = "AI_STATE_AMBLE",
	FollowTheLeader = "FollowTheLeader",
	TheLeader = "TheLeader";

	public static final String
	CanWalkThroughWalls = "CanWalkThroughWalls",
	BumpsPerSecond = "bumpsPerSecond",
	BumpsLastTime = "bumpsLastSecond";

	private final int rageLimit = 200;
	//	private int bumpsPerSecond = 0;
	//	private int bumpsLastSecond = 0;

	StrategyEngine crowdStrategies;// = new StrategyEngine();

	//Technniques
	public enum Crowd implements IMethods{
		DEFAULT("DoNothing"), Turn_180("Turn_180"), JumpUp("JumpUp"), Boost("Boost");

		private final String text;
		//
		/**
		 * @param text
		 */
		private Crowd(final String text) {
			this.text = text;
		}

		/* (non-Javadoc)
		 * @see java.lang.Enum#toString()
		 */
		@Override
		public String toString() {
			return text;
		}

		public int length() {
			return Crowd.values().length;
		}
		@Override
		public String[] Strings() {
			String[] strings = new String[Crowd.values().length];
			for (int i = 0; i<strings.length;++i) {
				strings[i] = values()[i].toString();
			}
			return strings;
		}


	}


	@Override
	protected void onAwake() {


		this.setState(Amble);
		this.setValue(CanWalkThroughWalls, false);

		this.crowdStrategies = new StrategyEngine(Crowd.DEFAULT, 10);

		this.crowdStrategies.addMethod(Crowd.DEFAULT,Strategy.DummyMethod());
		this.crowdStrategies.addMethod(Crowd.Turn_180, new AiMethod() {

			@Override
			public Strategy.State invoke(Strategy ai, int maxTurns, Object... args) {
				Node n = (Node) args[0];
				if (ai.getCount() == 0)
					n.transform.rootTransform().rotate("yaw", 180 * RMX.PI_OVER_180);

				return ai.getCount() > maxTurns ? Strategy.State.FINISHED : Strategy.State.WILL_CONTINUE;
			}

		});

		this.crowdStrategies.addMethod(Crowd.JumpUp, 10, new AiMethod() {

			@Override
			public State invoke(Strategy ai, int maxTurns, Object... args) {
				Node n = (Node) args[0];
				if (ai.getCount() == 0)
					n.broadcastMessage("Jump");
				return ai.getCount() > maxTurns ? Strategy.State.FINISHED : Strategy.State.WILL_CONTINUE;
			}

		});

		this.crowdStrategies.addMethod(Crowd.Boost, 10, new AiMethod(){

			@Override
			public State invoke(Strategy ai, int maxTurns, Object... args) {
				Node n = (Node) args[0];
				if (ai.getCount() < maxTurns)
					n.broadcastMessage("applyForce", "forward:-0.2");
				return ai.getCount() > maxTurns ? Strategy.State.FINISHED : Strategy.State.WILL_CONTINUE;
			}

		});
	}

	LinkedList<String> lastTechnique = new LinkedList<>();

	private boolean _ready = false;
	void tryToAvoidCrowding(long tick) {


		if (tick % 600 == 0) { //every 10 seconds
			Strategy ai = this.crowdStrategies.invokeCurrent(this);
			switch (ai.state()) {
			case FINISHED: //make judgement
				int lastCount = (int) this.getValueOrSetDefault(BumpsLastTime,0);
				int oldbps = (int) this.getValueOrSetDefault(BumpsPerSecond,0);
				int newbps = bumpCount - lastCount;
				this.setValue(BumpsLastTime, bumpCount);
				this.setValue(BumpsPerSecond, newbps);
				break;
			case WILL_NOT_WORK:
				ai.fail();
				break;
			}
		}

	}


	public void setDefaultState() {
		this.setState(FollowTheLeader);
		System.out.println("Amble");
	}

	//	public static Node TheLeader;

	protected Node leader() {
		Object theLeader = this.getValue(TheLeader);
		if (theLeader == null)
			theLeader = Leader;
		if (theLeader == this.getNode()) {
			setState(TheLeader);
			theLeader = null;
		}
		return theLeader != null ? (Node) theLeader : null;
	}


	@Override
	public void update(long tick) {
		this.tick = tick;
		switch (state()) {
		case Amble:
			this.applyForce("forward:0.2");
			this.applyTorque("yaw:0.05");//, Vector3.Zero);
			this.limit(AiCubo.bounds * 2);
			break;
		case Possessed:
			if (isStuck(tick))
				this.setNotStuck();
			//			this.limit(AiCubo.bounds * 3.2f);
			return;
		case FollowTheLeader:
			Node leader = this.leader();
			if (leader != null) {
				this.turnToFace(leader.transform.position());
				this.getNode().physicsBody().applyForce(0.2f, 
						Vector3.makeSubtraction(leader.transform.position(), this.transform().position()).getNormalized(), 
						Vector3.Zero);

			}
			//			this.limit(AiCubo.bounds * 3);
			break;
		case TheLeader:
			int max = rageLimit ; float bumpCount = this.bumpCount;
			if (bumpCount > 0 && tick % 5 == 0)
				bumpCount--;
			if (bumpCount > max)
				bumpCount = max + (bumpCount - max) * 0.05f;
			float speed = 0.01f * (bumpCount + 1);

			float turn = 0.001f * (max - bumpCount);
			this.applyForce("forward:" + speed);
			if (turn > 0)
				this.applyTorque("yaw:"+turn);//, Vector3.Zero);
			//			this.limit(AiCubo.bounds * 3.2f);
			break;

		}
		if (isStuck(tick)) {
			jump();
			this.setNotStuck();
		}

	}




	void limit(float bounds) {
		this.limit(bounds,true); 
	}
	boolean limit(float bounds, boolean doubleCheck) {
		Matrix4 m = this.transform().localMatrix();
		boolean outOfBounds = false;
		if (m.m30 > bounds) {
			m.m30 *= -0.5;
			m.m31 = (float)Tools.rBounds(10, 100);
			outOfBounds = true;
		} else if (m.m30 <= -bounds) {
			m.m30 *= -0.5;
			m.m31 = (float)Tools.rBounds(10, 100);
			outOfBounds = true;
		}
		if (m.m32 > bounds) {
			m.m32 *= -0.5;
			m.m31 = (float)Tools.rBounds(10, 100);
			outOfBounds = true;
		} else if (m.m32 <= -bounds) {
			m.m32 *= -0.5;
			m.m31 = (float)Tools.rBounds(10, 100);
			outOfBounds = true;
		}

		if (outOfBounds && doubleCheck && limit(bounds, false)) {
			m.m30 = m.m32 = 0;
			m.m31 = 200;
			outOfBounds = false;
		}
		return outOfBounds;
	}

	public static Node Leader;
	public void onEventDidEnd(String theEvent, Object args) {
		if (this.state() == Possessed) {
			System.out.println("I Am Possessed: " + theEvent + ", " + args);
			return;
		}
		switch (theEvent) {
		case TheLeader:
			if (this.state() != TheLeader)// && this.leader() == null)
				this.setValue(TheLeader, args);
			break;
		case CanWalkThroughWalls:
			this.setValue(CanWalkThroughWalls,Boolean.valueOf(args.toString()));
			break;
		case GET_AI_STATE:
			if (this.state() != Possessed)
				this.setState(args.toString());
			break;
		case FollowTheLeader:
			if (this.state() != Possessed && this.state() == FollowTheLeader)
				if ( args == "current")
					this.setValue(TheLeader, Node.getCurrent());
				else if ( args == "random")
					this.setValue(TheLeader, Node.randomAiNode());
				else if ( args != null && args.getClass() == Node.class)
					this.setValue(TheLeader, args);
				else
					this.setValue(TheLeader, Leader);
			break;
		}
	}

	@Override
	public void onCollisionStart(CollisionEvent event) {
		if (bumpCount > rageLimit * 5 || (Boolean) this.getValue(CanWalkThroughWalls)) {
			event.preventCollision(true);
		}
		String state = this.state();
		switch (state) {
		case TheLeader:
			if (event.getOther(this.getNode()).getValue(GET_AI_STATE) == FollowTheLeader)
				bumpCount++;
			break;
		case Amble:
		case FollowTheLeader:
			if (event.getOther(this.getNode()).getValue(TheLeader) == this) {
				this.setState(TheLeader);
				this.jump();
			}
			break;
		}
	}

	@Override
	public void invoke(long window, int key, int scancode, int action, int mods) {

	}
	private long tick;

	private int bumpCount = 0;
	@Override
	public void onCollisionEnd(CollisionEvent event) {
		// TODO Auto-generated method stub

		if (stuckState() == STUCK_FALSE && event.getPlaneDistance() > 0) {
			this.setMightBeStuck(this.tick);
		}




	}






}
