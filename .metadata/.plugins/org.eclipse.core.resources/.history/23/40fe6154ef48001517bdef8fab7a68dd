package click.rmx.engine;

import static click.rmx.RMX.getCurrentFramerate;

import java.util.Iterator;
import java.util.LinkedList;

import click.rmx.RMX;
import click.rmx.RMXObject;
import click.rmx.engine.math.Matrix4;
import click.rmx.engine.math.Vector3;
import junit.extensions.TestSetup;

public class PhysicsWorld extends RMXObject {
	private Vector3 gravity = new Vector3(0f,-9.8f,0f);
	private float friction = 0.3f;
	public Vector3 getGravity() {
		return gravity;
	}

	public void setGravity(Vector3 gravity) {
		this.gravity.set(gravity);
	}
	
	public void setGravity(float x, float y, float z) {
		this.gravity.x = x;
		this.gravity.y = y;
		this.gravity.z = z;
	}
	
	public void updatePhysics(Node rootNode) {
		for (Node node : rootNode.getChildren()) {
			if (node.physicsBody() != null) {
				node.physicsBody().updatePhysics(this);
			}
		}
	}

	public void updateCollisionEvents(Node rootNode) {
//		LinkedList<CollisionBody> unchecked = new LinkedList<>();
		if (unchecked.isEmpty())
			for (Node node : rootNode.getChildren()) {
				if (node.collisionBody() != null) {
					unchecked.add(node.collisionBody());			
				}
			}
		
		if (!unchecked.isEmpty()) {
			checkForCollisions(unchecked, checked);
//			System.out.println(count + " collisions found in " + checks + " checks");
			count = checks = 0;
			swapLists();
		} 
			
	}

	private void swapLists() {
		LinkedList<CollisionBody> temp = unchecked;
		unchecked = checked;
		checked = temp;
	}
	LinkedList<CollisionBody> checked = new LinkedList<>();
	LinkedList<CollisionBody> unchecked = new LinkedList<>();
	int count = 0; int checks = 0;
	public void checkForCollisions(LinkedList<CollisionBody> unchecked, LinkedList<CollisionBody> checked) {
		if (unchecked.isEmpty()) {
//			System.out.println(count + " collisions found in " + checks + " checks");
			return;
//			count = checks = 0;
//			swapLists();
		} else {
			CollisionBody A = unchecked.removeFirst();
			Iterator<CollisionBody> i = unchecked.iterator();
			while (i.hasNext()) {
				CollisionBody B = i.next();
				checks++;
				if (this.checkForCollision(A,B)) {
					count++;
					if (unchecked.remove(A))
						checked.addLast(A);
					if (unchecked.remove(B))
						checked.addLast(B);
					if (!unchecked.isEmpty()) {
						this.checkForCollisions(unchecked, checked);
						return;
					}
				}
			}
		}
	}
	Vector3 collisionDistance = new Vector3();
	private boolean checkForCollision(CollisionBody A, CollisionBody B) {
		float min = A.getNode().transform.radius() +
				B.getNode().transform.radius();
		collisionDistance.set(
				A.getNode().transform.position());
		collisionDistance.sub(
				B.getNode().transform.position());
		float distance = Math.abs(collisionDistance.length());
//				A.getNode().transform.position().length() +
//				A.getNode().transform.position().length()
//				);
	
		boolean isHit = distance < min;
		if (isHit) {
			processCollision(A.getNode(), B.getNode());
			System.out.println("HIT at distance: " + distance + " < " + min);
		} else {
//			System.out.println("MISS at distance: " + distance + " > " + min);
		}
		return isHit;
	}

	private Vector3 va = new Vector3();
	private Vector3 vb = new Vector3();
	private void processCollision(Node nodeA, Node nodeB) {
		va.set(nodeA.physicsBody().getVelocity());
		vb.set(nodeB.physicsBody().getVelocity());
		Vector3 hitPointA = Vector3.Zero;
		Vector3 hitPointB = Vector3.Zero;
		float massA = nodeA.transform.mass();
		float massB = nodeB.transform.mass();
		nodeA.physicsBody().applyForce(massB, va, hitPointA);
		nodeB.physicsBody().applyForce(massA, vb, hitPointB);
		va.scale(massA);
		vb.scale(massB);
		va.sub(vb);
		vb.sub(va);
		
		System.out.println("Velocities: " +
							"\n     "+ nodeA.uniqueName() + ": " + va + nodeB.uniqueName() + ": " + vb);
	}

	public float getFriction() {
		return friction;
	}

	public void setFriction(float friction) {
		this.friction = friction;
	}
	
	
	
}
