package click.rmx.engine.physics;

import click.rmx.engine.Node;
import click.rmx.engine.math.Vector3;

public class BoundingSphere extends CollisionBounds {

	public BoundingSphere(Node node) {
		super(node);
		// TODO Auto-generated constructor stub
	}

	public float radius() {
		return this.transform.scale().length();
//		new Vector3(
//				this.transform.collisionBody().boundingBox.xMax(),
//				this.transform.collisionBody().boundingBox.yMax(),
//				this.transform.collisionBody().boundingBox.zMax()
//				).length();
	}
	
	@Override
	public boolean intersects(CollisionBounds other) {
		BoundingSphere B = (BoundingSphere) other;
		float min = this.radius() +
				B.radius();
		Vector3 collisionDistance = new Vector3();
		collisionDistance.set(
				A.getNode().transform.position());
		collisionDistance.sub(
				B.getNode().transform.position());
		float distance = Math.abs(collisionDistance.length());
		//				A.getNode().transform.position().length() +
		//				A.getNode().transform.position().length()
		//				);

		boolean isHit = distance < min;
		if (isHit) {
			CollisionEvent e = new CollisionEvent(A.getNode(),B.getNode());
			if (collisionDelegate != null)
				collisionDelegate.handleCollision(A.getNode(), B.getNode(), e);
			//			System.out.println("HIT at distance: " + distance + " < " + min);
		} else {
			//			System.out.println("MISS at distance: " + distance + " > " + min);
		}
		return isHit;
	}

}
